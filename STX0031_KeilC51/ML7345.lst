C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ML7345
OBJECT MODULE PLACED IN .\STX0031_KeilC51\ML7345.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\ML7345.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\user\inc;.\include) 
                    -DEBUG OBJECTEXTEND PRINT(.\STX0031_KeilC51\ML7345.lst) TABS(2) OBJECT(.\STX0031_KeilC51\ML7345.obj)

line level    source

   1          #include "ML7345.h"
   2          
   3          //#include <stdlib.h>
   4          //#include <stdbool.h> /* For true/false definition                      */
   5          //#include <stdio.h>
   6          #include "spi.h"
   7          #include "gpio.h" // 芯片引脚定于
   8          #include "ram.h"
   9          #include "ID_Decode.h"
  10          #include "Type.h"
  11          #include "uart.h"
  12          
  13          //ROHM demo板 main fre=426.25;Vco Cal Range:425.85 - 431.85.MHz
  14          //TCXO = 24M
  15          xdata u8 Fre_426_075[8] = {0x23,0x08,0x19,0x99,0x23,0x07,0x91,0x11}; //426.075MHz频率设置
  16          xdata u8 Fre_429_350[8] = {0x23,0x0C,0x77,0x77,0x23,0x0B,0xEE,0xEF}; //429.350MHz频率设置
  17          xdata u8 Fre_429_550[8] = {0x23,0x0C,0xBB,0xBC,0x23,0x0C,0x33,0x33}; //429.550MHz频率设置
  18          xdata u8 Fre_426_750[8] = {0x23,0x09,0x00,0x00,0x23,0x08,0x77,0x77}; //426.750MHz频率设置
  19          xdata u8 Fre_429_175[8] = {0x23,0x0c,0x3b,0xbc,0x23,0x0b,0xb3,0x33}; //429.175MHz频率设置
  20          
  21          /**Receiver_vent**/ xdata u8 Receiver_vent_Cache = 0;
  22          xdata u32 SPI_Receive_DataForC[7]; //C郿
  23          xdata u8 SPI_RECEIVE_BUFF[40] = {0};
  24          
  25          /************Address: 0x20000500, Name: GENERIC_PKT_FRAME_CFG1***************************************/
  26          
  27          xdata u8 Radio_Date_Type = 1;
  28          xdata u8 tx_pack_cnt = 0;
  29          xdata u8 Radio_Date_Type_bak=1;
  30          xdata u8 APP_TX_freq=0;
  31          
  32          xdata u8 TX_Scan_step=0;
  33          xdata u8 First_TX_Scan=0;
  34          xdata u8 rf_offset = 0;
  35          
  36          xdata u8 Freq_SetBuff[8] = {0};
  37          /*
  38          Function: RF Init
  39          Parameter: Null
  40          Return: Null
  41          */
  42          /* Initialize: 426MHz General Packet(TCXO_ChStep=12.5kHz_DR=1.2kbps_Dev=0.6kHz_GFSK)
  43             发射功率0dBm */
  44          void RF_ML7345_Init(u8* freq,u8 sync,u8 rx_len)
  45          {
  46   1          ML7345_RESETN_SET();    /* Hardware Reset */
  47   1          while(1){
  48   2              if(ML7345_Read_Reg(0x0Du)&0x01u){   /* Wait Clock stabilization completion */
  49   3                  break;
  50   3              }
  51   2          }
  52   1          ML7345_Write_Reg(0x00,0x11);    /* Bank0 Set */
  53   1          ML7345_Write_Reg(0x01,0xff);    /* Software Reset */
  54   1          ML7345_Write_Reg(0x02,0x9f);    /* Clk Enable */
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 2   

  55   1          ML7345_Write_Reg(0x03,0xc3);    /* TCXO_EN */
  56   1          ML7345_Write_Reg(0x04,0x03);    /* MSB first,Format D (non Wireless M-Bus, general purpose format) */
  57   1          ML7345_Write_Reg(0x05,0x10);    /* CRC Disable,Length field 1-byte mode */
  58   1          ML7345_Write_Reg(0x06,0x00);    /* Data Rate: 0x00 1.2kbps; 0x22 4.8kbps */
  59   1          ML7345_Write_Reg(0x07,0x15);    /* GFSK,NRZ */
  60   1          ML7345_Write_Reg(0x08,0x00);    /* Sync word pattern 1,Manchester Do not inverse polarity */
  61   1          ML7345_Write_Reg(0x09,0x00);    /* CH 0 */
  62   1          ML7345_Write_Reg(0x0a,0x18);    /* AUTO_TX_EN */
  63   1          ML7345_Write_Reg(0x0b,0x88);    /* TRX_OFF */
  64   1          ML7345_Write_Reg(0x0c,0x00);    /* FIFO mode */
  65   1          ML7345_Write_Reg(0x0d,0x08);    /* [INT_SOURCE_GRP1],Interrupt status for INT0 to INT7 */
  66   1          ML7345_Write_Reg(0x0e,0x00);    /* [INT_SOURCE_GRP2],Interrupt status for INT8 to INT15 (RX) */
  67   1          ML7345_Write_Reg(0x0f,0x00);    /* [INT_SOURCE_GRP3],Interrupt status for INT16 to INT23 (TX) */
  68   1          ML7345_Write_Reg(0x10,0x00);    /* masking interrupt,[INT_EN_GRP1]Interupt mask for INT0 to INT7 */
  69   1          ML7345_Write_Reg(0x11,0x00);    /* masking interrupt,[INT_EN_GRP2]Interupt mask for INT8 to INT15 */
  70   1          ML7345_Write_Reg(0x12,0x00);    /* masking interrupt,[INT_EN_GRP3]Interupt mask for INT16 to INT23 */
  71   1          ML7345_Write_Reg(0x13,0x00);    /* [CRC_ERR_H]CRC error status (high byte) */
  72   1          ML7345_Write_Reg(0x14,0x00);    /* [CRC_ERR_M]CRC error status (middle byte)*/
  73   1          ML7345_Write_Reg(0x15,0x00);    /* [CRC_ERR_L]CRC error status (low byte)*/
  74   1          ML7345_Write_Reg(0x16,0x00);    /* State clear control */
  75   1          ML7345_Write_Reg(0x17,0x00);    /* TX FIFO-Full level setting */
  76   1          ML7345_Write_Reg(0x18,0x00);    /* TX FIFO-Empty level setting and TX trigger level setting in FAST_TX
             - mode */
  77   1          ML7345_Write_Reg(0x19,0x00);    /* RX FIFO-Full level disable and level setting */
  78   1          ML7345_Write_Reg(0x1a,0x00);    /* RX FIFO-Empty level disable and level setting (high byte) */
  79   1      
  80   1          ML7345_Write_Reg(0x2d,0x06);    /* SLEEP execution and Wake-up operation setting */
  81   1          /* Preamble */
  82   1          ML7345_Write_Reg(0x3f,0x05);    /* Preamble pattern setting,p198*/
  83   1      
  84   1          ML7345_Write_Reg(0x41,0x8B);    /* Enable ED value calculation,bit3=0 ED value constantly updated,bit3
             -=1 ED value acquired at SyncWord detection timing*/
  85   1      
  86   1          ML7345_Write_Reg(0x42,0x00);    //TX前导码长度高八位
  87   1          ML7345_Write_Reg(0x43,0x34);    //TX前导码长度低八位,不等少于16个位,TX preamble length =
             - (specified value x2) bits
  88   1          //----------------------------------------------------------------------------------------------------
             --
  89   1          ML7345_Write_Reg(0x45,0x08);    //接收前导码长度(bit) RX preamble setting and ED threshold chec
             -k setting
  90   1          //----------------------------------------------------------------------------------------------------
             --
  91   1          ML7345_Write_Reg(0x4e,0x00);    /* GPIO0 [output] “L” level */
  92   1          ML7345_Write_Reg(0x4f,0x00);    /* GPIO1 [output] “L” level,Upon reset,disable GPIO1 pin is CLK_OU
             -T function */
  93   1          ML7345_Write_Reg(0x50,0x00);    /* GPIO2 [output] “L” level */
  94   1          ML7345_Write_Reg(0x51,0x00);    /* GPIO3 [output] “L” level */
  95   1      
  96   1          ML7345_Write_Reg(0x54,0x14);    /* Channel filter bandwidth setting */
  97   1      
  98   1          ML7345_Write_Reg(0x60,0x06); /* Decimation gain setting 提高灵敏度 */
  99   1      
 100   1          ML7345_Write_Reg(0x63,0x88);    /* Fine adjustment of load capacitance for oscillation circuits */
 101   1      
 102   1          ML7345_Write_Reg(0x67,0x16);    /* 功率设置12dbm */
 103   1          ML7345_Write_Reg(0x68,0x10);    /* PA regulator fine adjustment */
 104   1          ML7345_Write_Reg(0x69,0x03);    /* PA gain adjustment */
 105   1      
 106   1          ML7345_Write_Reg(0x6e,0x5b);    /*5b VCO calibration setting or status indication */
 107   1      
 108   1          ML7345_Write_Reg(0x7a,0x00);    //发送包长度高八位
 109   1          ML7345_Write_Reg(0x7b,0x0c);    //发送包长度低八位
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 3   

 110   1      
 111   1          ML7345_Write_Reg(0x7d,0x00);    //接收包长度高八位
 112   1          ML7345_Write_Reg(0x7e,rx_len);    //接收包长度低八位
 113   1      
 114   1          /***************************************************************************************************/
 115   1      
 116   1          ML7345_Write_Reg(0x00,0x22);    /* Bank1 Set */
 117   1          ML7345_Write_Reg(0x02,0x07);    /* TX data rate conversion setting (high 4bits) */
 118   1          ML7345_Write_Reg(0x03,0xd0);    /* TX data rate conversion setting (low byte) */
 119   1          ML7345_Write_Reg(0x04,0x00);    /* RX data rate concversion setting 1 (high 4bits) */
 120   1          ML7345_Write_Reg(0x05,0x50);    /* RX data rate cnvesrion setting 1 (low byte) */
 121   1      
 122   1          ML7345_Write_Reg(0x11,0x27);    /* RSSI offset value setting during low gain operation */
 123   1      
 124   1          ML7345_Write_Reg(0x13,0x0c);    /* Scale factor setting for ED value conversion */
 125   1      
 126   1          ML7345_Write_Reg(0x1a,0x02);    /* Divide 2,PLL frequency division setting */
 127   1          /* 426.075MHz */
 128   1          ML7345_Write_Reg(0x1b,freq[0]);    /* TX frequency setting (I counter),p67-69 */
 129   1          ML7345_Write_Reg(0x1c,freq[1]);    /* TX frequency setting (F counter high 4bit) */
 130   1          ML7345_Write_Reg(0x1d,freq[2]);    /* TX frequency setting (F counter middle byte) */
 131   1          ML7345_Write_Reg(0x1e,freq[3]);    /* TX frequency setting (F counter low byte) */
 132   1          ML7345_Write_Reg(0x1f,freq[0]);    /* RX frequency setting (I counter) */
 133   1          ML7345_Write_Reg(0x20,freq[1]);    /* RX frequency setting (F counter high 4bit)  */
 134   1          ML7345_Write_Reg(0x21,freq[2]);    /* RX frequency setting (F counter middle byte) */
 135   1          ML7345_Write_Reg(0x22,freq[3]);    /* RX frequency setting (F counter low byte) */
 136   1      
 137   1          ML7345_Write_Reg(0x23,0x08);    /* 25KHz,Channel space setting (high byte) */
 138   1          ML7345_Write_Reg(0x24,0x88);    /* Channel space setting (low byte) */
 139   1          /* SyncWord 0x00005515 */
 140   1          ML7345_Write_Reg(0x25,0x08);    /* SyncWord length setting */
 141   1          ML7345_Write_Reg(0x26,0x0f);    /* SyncWord enable setting */
 142   1          ML7345_Write_Reg(0x27,0x00);    /* SyncWord #1 setting (bit24 to 31) */
 143   1          ML7345_Write_Reg(0x28,0x00);    /* SyncWord #1 setting (bit16 to 23) */
 144   1          ML7345_Write_Reg(0x29,0x00);    /* SyncWord #1 setting (bit8 to 15) */
 145   1          ML7345_Write_Reg(0x2a,sync);    /* SyncWord #1 setting (bit0 to 7) */
 146   1      
 147   1          ML7345_Write_Reg(0x2f,0x08);    /* GFSK clock setting x8 clock,GFSK/FSK modulation timing resolution s
             -etting */
 148   1          ML7345_Write_Reg(0x30,0x00);    /* GFSK frequency deviation setting (high 6bits) */
 149   1          ML7345_Write_Reg(0x31,0xAE);    /* P71  GFSK frequency deviation:2.0KHz,GFSK frequency deviation setti
             -ng (low byte) */
 150   1      
 151   1          /*(Channel#0 frequency-400khz)426.075:0x23 0x07 0x91 0x11;
 152   1          426.25:0x23 0x07 0xcc 0xcc */
 153   1          ML7345_Write_Reg(0x4d,freq[4]);    /* VCO calibration low limit frequency setting (I counter),p254 */
 154   1          ML7345_Write_Reg(0x4e,freq[5]);    /* VCO calibration low limit frequency setting (F counter high 4bit
             -s) */
 155   1          ML7345_Write_Reg(0x4f,freq[6]);    /* VCO calibration low limit frequency setting (F counter middle by
             -te) */
 156   1          ML7345_Write_Reg(0x50,freq[7]);    /* VCO calibration low limit frequency setting (F counter low byte)
             - */
 157   1          ML7345_Write_Reg(0x51,0x04);    /* 6 MHz,VCO calibration upper limit frequency setting */
 158   1          ML7345_Write_Reg(0x52,0x5a);    /* VCO calibration low limit value indication and setting */
 159   1          ML7345_Write_Reg(0x53,0x66);    /* VCO calibration upper limit value indication and setting */
 160   1      
 161   1          ML7345_Write_Reg(0x5c,0x15);    /* 0x10 Demodulator configulation 6 */
 162   1          ML7345_Write_Reg(0x5d,0x1b);    /* 0x1b Demodulator configulation 7 */
 163   1          ML7345_Write_Reg(0x5e,0x05);    /* 0x05 Demodulator configuration 8 */
 164   1          ML7345_Write_Reg(0x5f,0x67);    /* 0x67 Demodulator configulation 9 */
 165   1          ML7345_Write_Reg(0x60,0x0c);    /* Demodulator configulation 10 */
 166   1      
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 4   

 167   1          SetReg_Rssi();  //2021.11.17 ROHM提出必要设置,否则读取RSSI偏差大。
 168   1      
 169   1          ML7345_Write_Reg(0x00,0x44); //bank2
 170   1          ML7345_Write_Reg(0x2a,0x0f); //2019.11.25 ROHM提出设置,设置之后灵敏度提升了2dBm
 171   1      
 172   1          /* 以下寄存器值为发送功率必要设置，不然发送功率偏差大 */
 173   1          ML7345_Write_Reg(0x00,0x44); //bank2
 174   1          ML7345_Write_Reg(0x4f,0x00);
 175   1      
 176   1          ML7345_Write_Reg(0x00,0x88); //bank3
 177   1          ML7345_Write_Reg(0x2f,0x3f);
 178   1          ML7345_Write_Reg(0x0c,0x41);
 179   1          ML7345_Write_Reg(0x0d,0x33);
 180   1          ML7345_Write_Reg(0x0e,0x54);
 181   1          ML7345_Write_Reg(0x14,0x10);
 182   1          ML7345_Write_Reg(0x24,0x03);
 183   1          ML7345_Write_Reg(0x7e,0x00);
 184   1      
 185   1          if((PROFILE_CH_FREQ_32bit_200002EC == 429350000) || (PROFILE_CH_FREQ_32bit_200002EC == 429550000)) ML7
             -345_DataRate_Set_4_8k();
 186   1          else    ML7345_DataRate_Set_1_2k();
 187   1          /*****************************************************/
 188   1      
 189   1          ML7345_Write_Reg(0x00, 0x11);     /* BANK_SEL(BANK0) */
 190   1          ML7345_Write_Reg(0x6f, 0x01);     /* VCO_CAL_START(CAL start) */
 191   1          while(1){
 192   2              if(ML7345_Read_Reg(0x0Du)&0x02u){   /* Wait VCO calibration completion */
 193   3                  break;
 194   3              }
 195   2          }
 196   1          ML7345_AllStateFlag_Clear(); //清除所有标志
 197   1      }
 198          
 199          void ML7345_MeasurBER_Init(void)
 200          {
 201   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK1_SEL);
 202   1          ML7345_Write_Reg(0x0e,0x00);
 203   1      
 204   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK3_SEL);
 205   1          ML7345_Write_Reg(0x0d,0x33);
 206   1      
 207   1          ML7345_Write_Reg(ADDR_BANK_SEL,BANK0_SEL);
 208   1          ML7345_Write_Reg(0x0c,0x40); //50   /* DIO_SET, continuous output mode,DCLK is constantly output,no OU
             -TPUT (NOT stop output)*/
 209   1          ML7345_Write_Reg(0x4d,0x80); //80
 210   1      
 211   1          ML7345_Write_Reg(0x4E,0x05);    //ML7345D GPIO0 DCLK
 212   1          ML7345_Write_Reg(0x51,0x04);    //ML7345D GPIO3 DIO
 213   1      }
 214          
 215          
 216          void DataReceive(void)
 217          {
 218   1          static u8 StateCache = 0;
 219   1          static u8 Cache = 0;
 220   1          static u8 X_HISbyte = 0;
 221   1          switch (StateCache)
 222   1          {
 223   2              case 0:
 224   2              {
 225   3                  Cache <<= 1;
 226   3                  if (ML7345_DATA)
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 5   

 227   3                      Cache++;
 228   3                  if (Cache == 0x55)
 229   3                  {
 230   4                      StateCache = 1;
 231   4                      X_HISbyte = 0;
 232   4                      Cache = 0;
 233   4                  }
 234   3              }
 235   2              break;
 236   2              case 1:
 237   2              {
 238   3                  if (ML7345_DATA != X_HISbyte)
 239   3                      X_ERR++;
 240   3                  X_COUNT++;
 241   3                  X_HISbyte ^= 1;
 242   3                  if (X_COUNT >= 1000)
 243   3                      StateCache = 2;
 244   3              }
 245   2              break;
 246   2              case 2:
 247   2                  if (X_COUNT == 0)
 248   2                      StateCache = 0;
 249   2                  break;
 250   2              default:
 251   2                  break;
 252   2          }
 253   1      }
 254          
 255          
 256          
 257          void Tx_Data_Test(u8 mode)
 258          {
 259   1          ML7345_Write_Reg(0x00, 0x11);     /* BANK_SEL(BANK0) */
 260   1          switch(mode)
 261   1          {
 262   2              /* 发送：载波 */
 263   2              case 0: ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x21);break;
 264   2      
 265   2              /* 发送：0101 */
 266   2              case 1:ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x11);break;
 267   2      
 268   2              /* 发送：0 */
 269   2              case 2:ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x09);break;
 270   2      
 271   2              /* 发送：1 */
 272   2              case 3: ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x05);break;
 273   2      
 274   2               /* 发送：随机 */
 275   2              default:
 276   2                  ML7345_Write_Reg(ADDR_RF_TEST_MODE,0x03);
 277   2               break;
 278   2          }
 279   1          ML7345_SetAndGet_State(TX_ON);
 280   1      }
 281          
 282          
 283          void RF_Ber_Test(void)
 284          {
 285   1          if (X_COUNT >= 1000)
 286   1          {
 287   2              if (X_ERR >= 50) Receiver_LED_RX = 0;
 288   2              else             Receiver_LED_RX = 1;
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 6   

 289   2              X_ERR = 0;
 290   2              X_COUNT = 0;
 291   2              X_ERRTimer = 1250;
 292   2          }
 293   1          if (X_ERRTimer == 0)
 294   1              Receiver_LED_RX = 0;
 295   1      }
 296          
 297          void Uart_RF_Ber_Test(void)
 298          {
 299   1          if (X_COUNT >= 1000)
 300   1          {
 301   2              if(X_ERR > 255)  X_ERR_CNT = 255;
 302   2              else X_ERR_CNT = X_ERR;
 303   2      
 304   2              if (X_ERR >= 50) Receiver_LED_RX = 0;
 305   2              else             Receiver_LED_RX = 1;
 306   2      
 307   2              X_ERR = 0;
 308   2              X_COUNT = 0;
 309   2              X_ERRTimer = 1250;
 310   2          }
 311   1          if (X_ERRTimer == 0)
 312   1              Receiver_LED_RX = 0;
 313   1      }
 314          
 315          void APP_TX_PACKET(void)
 316          {
 317   1           xdata char rssi;
 318   1         xdata u8 i=2,j=0;
 319   1      
 320   1         if((TP3==0)&&(FLAG_Key_TP3==0))FLAG_Key_TP3=1;
 321   1      
 322   1            if((Time_error_read_timeout==0)&&(Flag_ERROR_Read==1))
 323   1            {
 324   2            Flag_ERROR_Read=0;
 325   2          FLAG_APP_TX_fromUART_err_read=0;
 326   2            }
 327   1            if( (Flag_FREQ_Scan==0) && ((PROFILE_CH_FREQ_32bit_200002EC == 429350000)||(PROFILE_CH_FREQ_32bit_20
             -0002EC == 429550000)) &&
 328   1              ((FLAG_APP_TX_fromUART_err_read==1) && (Flag_ERROR_Read==1) && (Time_error_read_gap==0) && ((FLAG_AP
             -P_RX==1)||(FLAG_APP_RXstart==1)) && (Radio_Date_Type_bak==2))
 329   1               )
 330   1            {
 331   2               for(j=0;j<8;j++)Last_Uart_Struct_DATA_Packet_Contro.Data[j/2].uc[j%2]=0x00;
 332   2      
 333   2               Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.type=0x1f;
 334   2           Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[0]=0x98;
 335   2           ERROR_Read_sendTX_packet++;
 336   2           Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1]=ERROR_Read_sendTX_packet;
 337   2           while(ERROR_Read_sendTX_count<UART_DATA_ID98[1]-4)
 338   2           {
 339   3               Last_Uart_Struct_DATA_Packet_Contro.Data[i/2].uc[i%2]=UART_DATA_ID98[ERROR_Read_sendTX_count+4];
 340   3             ERROR_Read_sendTX_count++;
 341   3             i++;
 342   3             if(i==8)break;
 343   3           }
 344   2           if(ERROR_Read_sendTX_count==UART_DATA_ID98[1]-4)
 345   2           {
 346   3            Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1]= Last_Uart_Struct_DATA_Packet_Contro.Data[0].uc[1] |
             -0x80;
 347   3            FLAG_APP_TX_fromUART_err_read=0;
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 7   

 348   3            Flag_ERROR_Read=0;
 349   3           }
 350   2      
 351   2           DEF_APP_TX_freq=3;
 352   2           FLAG_APP_TX=1;
 353   2           FLAG_APP_RX=0;
 354   2           //FLAG_APP_RXstart=0;
 355   2           APP_TX_freq=0;
 356   2           TX_Scan_step=1;
 357   2           First_TX_Scan=0;
 358   2      
 359   2          }
 360   1            else if((Flag_FREQ_Scan==0)&&((PROFILE_CH_FREQ_32bit_200002EC == 429350000)||(PROFILE_CH_FREQ_32bit_
             -200002EC == 429550000))&&
 361   1              (((FLAG_APP_TX_fromOUT==1)&&(TIME_APP_TX_fromOUT==0))||(FLAG_Key_TP3==1)||
 362   1               //((FLAG_APP_TX_fromUART==1)&&(((TIME_APP_TX_fromOUT==0)&&(Radio_Date_Type_bak==2))||((TIMER300ms==
             -0)&&(Radio_Date_Type_bak==1)))&&(Uart_Struct_DATA_Packet_Contro.data[0].ui!=Last_Uart_Struct_DATA_Packet_Contro.data[0].
             -ui))
 363   1               ((FLAG_APP_TX_fromUART==1)&&(((TIME_APP_TX_fromOUT==0)&&(Radio_Date_Type_bak==2))||((TIMER300ms==0)
             -&&(Radio_Date_Type_bak==1))))
 364   1            )
 365   1            )
 366   1          {
 367   2                  FLAG_APP_TX_fromUART=0;
 368   2                  FLAG_Key_TP3=0;
 369   2                  Last_Uart_Struct_DATA_Packet_Contro=Uart_Struct_DATA_Packet_Contro;
 370   2                  Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.type=1;
 371   2                  rssi=(RAM_RSSI_AVG - 255)/3 - 51;
 372   2                            rssi = -rssi;
 373   2                  if(Radio_Date_Type_bak==2)rssi= rssi | 0x80;
 374   2                  Last_Uart_Struct_DATA_Packet_Contro.Data[1].uc[0]= rssi;
 375   2                  if(FLAG_APP_TX_fromOUT==1) Last_Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.fno= Struct_DATA_Packet_
             -Contro_fno;
 376   2                  FLAG_APP_TX_fromOUT=0;
 377   2                  TIME_APP_TX_fromOUT=0;
 378   2      
 379   2                  DEF_APP_TX_freq=3;
 380   2                  FLAG_APP_TX=1;
 381   2                  FLAG_APP_RX=0;
 382   2                  APP_TX_freq=0;
 383   2                  TX_Scan_step=1;
 384   2                  First_TX_Scan=0;
 385   2      
 386   2                            RSSI_Read_Counter = 0;
 387   2                            RAM_RSSI_SUM = 0;
 388   2          }
 389   1          if(FLAG_APP_TX == 1)
 390   1          {
 391   2              if(TX_Scan_step==1)TX_Scan_step=2;
 392   2             if(TX_Scan_step==2)
 393   2             {
 394   3              if(APP_TX_freq==0)
 395   3              {
 396   4                          Flag_tx_en = 1;
 397   4                          TIMER18ms = 300;
 398   4                  Receiver_LED_TX = 1;
 399   4                TX_DataLoad_HighSpeed(ID_SCX1801_DATA,Last_Uart_Struct_DATA_Packet_Contro, &CONST_TXPACKET_DATA_20000
             -AF0[0]);
 400   4                          ML7345_SetAndGet_State(Force_TRX_OFF);
 401   4                          ML7345_Write_Reg(0x00,0x22);    // Bank1 Set
 402   4                          ML7345_Write_Reg(0x2a,0x15);    //sync
 403   4                          ML7345_Write_Reg(ADDR_BANK_SEL,BANK0_SEL);
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 8   

 404   4                          ML7345_GPIO0TxDoneInt_Enable();
 405   4                          ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 406   4                          Time_Tx_Out = 100;
 407   4                APP_TX_freq=1; //1
 408   4              }
 409   3              else if((APP_TX_freq < DEF_APP_TX_freq) && (Flag_TxDone == 1) && (Time_APP_blank_TX == 0))
 410   3              {
 411   4                          Flag_TxDone = 0;
 412   4                          ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 413   4                          Time_Tx_Out = 100;
 414   4                APP_TX_freq++;
 415   4              }
 416   3              else if((APP_TX_freq == DEF_APP_TX_freq) && (Flag_TxDone == 1) && (Time_APP_blank_TX == 0))
 417   3              {
 418   4                          Flag_TxDone = 0;
 419   4                          APP_TX_freq++;
 420   4                          FLAG_APP_RXstart=1;
 421   4                          FLAG_APP_TX=0;
 422   4                          Time_APP_RXstart=1;
 423   4                          Receiver_LED_TX = 0;
 424   4                          FLAG_APP_TX_once=0;
 425   4                          Flag_tx_en = 0;
 426   4                          retx_cnt = 0;
 427   4              }
 428   3             }
 429   2          }
 430   1          if((FLAG_APP_RXstart==1)&&(Time_APP_RXstart==0)&&(FLAG_APP_TX_fromUART_err_read==0))
 431   1          {
 432   2              FLAG_APP_RXstart = 0;
 433   2              FLAG_APP_RX = 1;
 434   2          }
 435   1          else if(Flag_tx_en == 1 && Time_Tx_Out == 0 && Flag_TxDone == 0 && FLAG_APP_RXstart == 0)
 436   1          {
 437   2              if(PROFILE_CH_FREQ_32bit_200002EC == 429350000) RF_ML7345_Init(Fre_429_350,0x15,28);
 438   2              else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000) RF_ML7345_Init(Fre_429_550,0x15,28);
 439   2              ML7345_GPIO0TxDoneInt_Enable();
 440   2              ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 441   2              Time_Tx_Out = 100;
 442   2              retx_cnt++;
 443   2              if(retx_cnt >= 3)
 444   2              {
 445   3                  retx_cnt = 0;
 446   3                  Flag_tx_en = 0;
 447   3                  FLAG_APP_RX = 1;
 448   3                  Receiver_LED_TX = 0;
 449   3              }
 450   2          }
 451   1      }
 452          
 453          //--------------------------------------------------------------------------------------------------
 454          void ML7345D_RF_test_mode(void)
 455          {
 456   1          Receiver_LED_OUT = 1;
 457   1          Flag_test_mode = 0;
 458   1          Flag_test_pc = 0;
 459   1          while (Receiver_test == 0)
 460   1          {
 461   2              if(Flag_test_mode == 0)
 462   2              {
 463   3                  //UART1_INIT_TestMode();
 464   3                  Receiver_LED_OUT = 0;
 465   3                  BEEP_Module(500,1);
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 9   

 466   3              }
 467   2              Flag_test_mode = 1;
 468   2              ClearWDT();   // Service the WDT
 469   2              if(Flag_test_pc == 0)
 470   2              {
 471   3                  if (TP4 == 0) //test  TX
 472   3                  {
 473   4                      if (TP3 == 0)
 474   4                          Tx_Rx_mode = 0;
 475   4                      else
 476   4                          Tx_Rx_mode = 1;
 477   4                  }
 478   3                  else //test  RX
 479   3                  {
 480   4                      if (TP3 == 0)
 481   4                          Tx_Rx_mode = 2;
 482   4                      else
 483   4                          Tx_Rx_mode = 3;
 484   4                  }
 485   3                  if ((Tx_Rx_mode == 0) || (Tx_Rx_mode == 1))
 486   3                  {
 487   4                      CG2214M6_USE_T;
 488   4                      FG_test_rx = 0;
 489   4                      Receiver_LED_RX = 0;
 490   4                      FG_test_tx_off = 0;
 491   4                      Flag_test_rssi = 0;
 492   4                      PROFILE_CH_FREQ_32bit_200002EC = 429175000;
 493   4                      if (Tx_Rx_mode == 0) //发载波，无调制信叿
 494   4                      {
 495   5                          Receiver_LED_TX = 1;
 496   5                          FG_test_mode = 0;
 497   5                          FG_test_tx_1010 = 0;
 498   5                          if (FG_test_tx_on == 0)
 499   5                          {
 500   6                              FG_test_tx_on = 1;
 501   6                              ML7345_SetAndGet_State(Force_TRX_OFF);
 502   6                              ML7345_Frequency_Set(Fre_429_175,1);
 503   6                              Tx_Data_Test(0);
 504   6                          }
 505   5                      }
 506   4                      else //发载波，有调制信叿
 507   4                      {
 508   5                          if (TIMER1s == 0)
 509   5                          {
 510   6                              TIMER1s = 500;
 511   6                              Receiver_LED_TX = !Receiver_LED_TX;
 512   6                          }
 513   5                          FG_test_mode = 1;
 514   5                          FG_test_tx_on = 0;
 515   5                          if (FG_test_tx_1010 == 0)
 516   5                          {
 517   6                              FG_test_tx_1010 = 1;
 518   6                              ML7345_SetAndGet_State(Force_TRX_OFF);
 519   6                              ML7345_Frequency_Set(Fre_429_175,1);
 520   6                              Tx_Data_Test(1);
 521   6                          }
 522   5                      }
 523   4                  }
 524   3                  //else  {           //test  RX
 525   3                  if ((Tx_Rx_mode == 2) || (Tx_Rx_mode == 3))
 526   3                  {
 527   4                      CG2214M6_USE_R;
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 10  

 528   4                      FG_test_rx = 1;
 529   4                      Receiver_LED_TX = 0;
 530   4                      FG_test_mode = 0;
 531   4                      FG_test_tx_on = 0;
 532   4                      FG_test_tx_1010 = 0;
 533   4                      if (FG_test_tx_off == 0)
 534   4                      {
 535   5                          FG_test_tx_off = 1;
 536   5                          ML7345_SetAndGet_State(Force_TRX_OFF);
 537   5                          PROFILE_CH_FREQ_32bit_200002EC = 426750000;
 538   5                          ML7345_Frequency_Set(Fre_426_750,1);
 539   5                          ML7345_MeasurBER_Init();
 540   5                          ML7345_SetAndGet_State(RX_ON);
 541   5                      }
 542   4                      if (Tx_Rx_mode == 2) //packet usart out put RSSI
 543   4                      {
 544   5                          if (TIMER1s == 0)
 545   5                          {
 546   6                              TIMER1s = 500;
 547   6                              Receiver_LED_RX = !Receiver_LED_RX;
 548   6                          }
 549   5                          //SCAN_RECEIVE_PACKET(); //扫描接收数据
 550   5                      }
 551   4                      if (Tx_Rx_mode == 3) //packet usart out put BER
 552   4                      {
 553   5                          RF_Ber_Test();
 554   5                      }
 555   4                  }
 556   3              }
 557   2              PC_PRG();
 558   2          }
 559   1          if(Flag_test_mode == 1)
 560   1          {
 561   2              //UART1_INIT();
 562   2              ML7345_SetAndGet_State(Force_TRX_OFF);
 563   2              RF_ML7345_Init(Fre_426_075,0x55,12);
 564   2          }
 565   1          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 566   1      
 567   1          Flag_test_mode = 0;
 568   1          Flag_test_pc = 0;
 569   1          ML7345_GPIO0RxDoneInt_Enable(); /* 开启接收完成中断,ML7345D GPIO0中断输出 */
 570   1          ML7345_GPIO0TxDoneInt_Enable(); /* 开启发送完成中断,ML7345D GPIO0中断输出 */
 571   1          FG_test_rx = 0;
 572   1          TIMER1s = 0;
 573   1          Receiver_LED_TX = 0;
 574   1          Receiver_LED_RX = 0;
 575   1          FG_Receiver_LED_RX = 0;
 576   1          //Receiver_LED_OUT = 0;
 577   1          Time_rf_init = 1000;
 578   1          FLAG_APP_RX = 1;
 579   1      }
 580          
 581          void ML7345d_Change_Channel(void)
 582          {
 583   1          if ((FLAG_ID_Erase_Login == 1) || (FLAG_ID_Login == 1) ||(FLAG_ID_SCX1801_Login==1))
 584   1          {
 585   2              PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 586   2              Radio_Date_Type=1;
 587   2              Channels=1;
 588   2              ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);
 589   2          }
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 11  

 590   1          else
 591   1          {
 592   2              switch(Channels)
 593   2              {
 594   3                  case 1:
 595   3                          Radio_Date_Type = 1;
 596   3                          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 597   3                          ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);       //加上VCO校准后用时5ms
             -，不加1.2ms
 598   3                          if(ID_SCX1801_DATA == 0) Channels = 1;
 599   3                          else Channels = 2;
 600   3                          break;
 601   3      
 602   3                  case 2:
 603   3                          Radio_Date_Type = 2;
 604   3                          PROFILE_CH_FREQ_32bit_200002EC = 429350000;
 605   3                          ML7345_Frequency_Set(Fre_429_350,Radio_Date_Type);
 606   3                          Channels = 3;
 607   3                          break;
 608   3      
 609   3                  case 3:
 610   3                          Radio_Date_Type = 2;
 611   3                          PROFILE_CH_FREQ_32bit_200002EC = 429550000;
 612   3                          ML7345_Frequency_Set(Fre_429_550,Radio_Date_Type);
 613   3                          Channels = 4;
 614   3                          break;
 615   3      
 616   3                   case 4:
 617   3                          Radio_Date_Type = 1;
 618   3                          PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 619   3                          ML7345_Frequency_Set(Fre_426_075,Radio_Date_Type);
 620   3                          Channels = 1;
 621   3                          break;
 622   3      
 623   3                   default:
 624   3                      break;
 625   3              }
 626   2          }
 627   1      }
 628          
 629          void ML7345D_Freq_Scanning(void)
 630          {
 631   1          if(TIMER18ms == 0)
 632   1          {
 633   2              if(Flag_FREQ_Scan)  return;
 634   2              ML7345d_Change_Channel();
 635   2              if(Time_rf_init == 0)
 636   2              {
 637   3                  Time_rf_init = 1000;
 638   3                  if(PROFILE_CH_FREQ_32bit_200002EC == 426075000) RF_ML7345_Init(Fre_426_075,0x55,12);
 639   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429350000) RF_ML7345_Init(Fre_429_350,0x55,28);
 640   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000) RF_ML7345_Init(Fre_429_550,0x55,28);
 641   3                  ML7345_GPIO0RxDoneInt_Enable();
 642   3              }
 643   2              ML7345_SetAndGet_State(RX_ON);
 644   2              CG2214M6_USE_R;
 645   2      
 646   2              if(Radio_Date_Type==1)
 647   2                  TIMER18ms = 18;
 648   2              else if(Radio_Date_Type > 1)
 649   2                  TIMER18ms = 18;
 650   2              Flag_rx_pream = 0;
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 12  

 651   2              Flag_tx_en = 0;
 652   2              RSSI_Read_Counter = 0;
 653   2              RAM_RSSI_SUM = 0;
 654   2      
 655   2          }else Flag_FREQ_Scan = 0;
 656   1      }
 657          
 658          //idata u8 red = 0;
 659          void ML7345_TRX_Del(void)
 660          {
 661   1          idata u8 reg = 0;
 662   1          if(Flag_tx_en == 0) reg = RF_SyncWord_DONE();
 663   1      
 664   1          if(reg == 0x20)
 665   1          {
 666   2              TIMER18ms = 550;
 667   2              Flag_FREQ_Scan = 1;
 668   2              if(Flag_rx_pream == 0 && Flag_set_freq == 0)
 669   2              {
 670   3                  FG_Receiver_LED_RX = 1;
 671   3                  ML7345_SetAndGet_State(Force_TRX_OFF);
 672   3                  if(PROFILE_CH_FREQ_32bit_200002EC == 426075000)
 673   3                  {
 674   4                      TIMER300ms = 600;
 675   4                      if(Flag_TX_ID_load == 0)    RF_ML7345_Init(Fre_426_075,0x15,12);
 676   4                      else                        RF_ML7345_Init(Fre_426_075,0x15,24);
 677   4                  }
 678   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429350000)   {RF_ML7345_Init(Fre_429_350,0x15,28); T
             -IMER300ms = 100;}
 679   3                  else if(PROFILE_CH_FREQ_32bit_200002EC == 429550000)   {RF_ML7345_Init(Fre_429_550,0x15,28); T
             -IMER300ms = 100;}
 680   3                  ML7345_GPIO0RxDoneInt_Enable();
 681   3                  ML7345_SetAndGet_State(RX_ON);
 682   3                  CG2214M6_USE_R;
 683   3              }
 684   2              Flag_rx_pream = 1;
 685   2              ML7345_Write_Reg(ADDR_INT_SOURCE_GRP2,0x00); //清接收完成标志
 686   2          }
 687   1          
 688   1          if(reg == 0x01)
 689   1          {
 690   2              if(TIMER18ms < 50) TIMER18ms = 50;
 691   2              Flag_RxDone = 1;
 692   2              ML7345_Write_Reg(ADDR_INT_SOURCE_GRP2,0x00); //清接收完成标志
 693   2              //ML7345_StateFlag_Clear(RX_DONE_FLAG); //清除后接收的数据会被清0
 694   2          }
 695   1          
 696   1          reg = ML7345_Read_Reg(ADDR_INT_SOURCE_GRP3);
 697   1          if(((reg & 0x01) == 0x01) && (reg != 0xff))
 698   1          {
 699   2              Flag_TxDone = 1;
 700   2              Time_APP_blank_TX = 6;
 701   2              ML7345_StateFlag_Clear(TX_DONE_FLAG);
 702   2          }
 703   1      }
 704          
 705          void RX_ANALYSIS(void)
 706          {
 707   1          xdata u8 i;
 708   1          for (i = 0; i < 7; i++)
 709   1          {
 710   2              SPI_Receive_DataForC[i] = (u32)SPI_RECEIVE_BUFF[i * 4 + 3] |
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 13  

 711   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 2] << 8 |
 712   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 1] << 16 |
 713   2                                        (u32)SPI_RECEIVE_BUFF[i * 4 + 0] << 24;
 714   2          }
 715   1        if(Flag_ERROR_Read==0)
 716   1        {
 717   2             FLAG_Receiver_IDCheck = 1;
 718   2             ID_Decode_IDCheck();
 719   2        }
 720   1      }
 721          
 722          void SCAN_RECEIVE_PACKET(void)
 723          {
 724   1          xdata short Cache;
 725   1          if(Flag_RxDone)
 726   1          {
 727   2              Flag_RxDone = 0;
 728   2              if(PROFILE_CH_FREQ_32bit_200002EC == 426075000)
 729   2              {
 730   3                  if(Flag_TX_ID_load == 1)    ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,24);
 731   3                  else                        ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,12);
 732   3              }
 733   2              else    ML7345_ReadRx_Pack(SPI_RECEIVE_BUFF,28);
 734   2              ML7345_StateFlag_Clear(RX_DONE_FLAG);
 735   2              RX_ANALYSIS();
 736   2              Flag_FREQ_Scan = 0;
 737   2      
 738   2              ML7345_SetAndGet_State(Force_TRX_OFF);
 739   2              Cache = ML7345_Read_Reg(ADDR_ED_RSLT);
 740   2              RAM_RSSI_SUM += Cache;
 741   2              RSSI_Read_Counter++;
 742   2              RAM_RSSI_AVG = RAM_RSSI_SUM / RSSI_Read_Counter;
 743   2              ML7345_Write_Reg(0x00,0x22);    // Bank1 Set
 744   2              ML7345_Write_Reg(0x2a,0x55);    //sync
 745   2              ML7345_Write_Reg(0x00,0x11);    // Bank0 Set
 746   2              ML7345_SetAndGet_State(RX_ON);
 747   2              CG2214M6_USE_R;
 748   2              Flag_rx_pream = 0;
 749   2              TIMER18ms = 28;
 750   2          }
 751   1      }
 752          /*
 753          void ML7345D_Error_Detect(void)
 754          {
 755              if(ML7345_Read_Reg(ADDR_INT_SOURCE_GRP1) & 0x04)    //PLL unlock interrupt
 756              {
 757                  ML7345_Write_Reg(ADDR_INT_SOURCE_GRP1,0xFB);
 758                  while(ML7345_SetAndGet_State(Get_Sta) != TRX_OFF);
 759                  ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 760              }
 761              else if(ML7345_Read_Reg(ADDR_INT_SOURCE_GRP3) & 0x10)    //TX FIFO access error interrupt
 762              {
 763                  ML7345_SetAndGet_State(Force_TRX_OFF);
 764                  ML7345_StateFlag_Clear(TX_DONE_FLAG);
 765                  ML7345_AutoTx_Data(CONST_TXPACKET_DATA_20000AF0,28);
 766              }
 767          }*/
 768          
 769          /*
 770          void TX_DataLoad(u32 IDCache, u8 CtrCmd, u8 *Packet)
 771          {
 772              xdata u8 i;
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 14  

 773              xdata u16 CRCTemp = 0;
 774              CRCTemp = (IDCache & 0xffff) + (((IDCache >> 16) & 0xff) + ((u16)CtrCmd << 8));
 775              for (i = 0; i < 24; i++)
 776              {
 777                  *(Packet + (i / 4)) <<= 2;
 778                  *(Packet + (i / 4)) |= ((IDCache & ((u32)1 << i)) ? 2 : 1);
 779              }
 780              for (i = 24; i < 32; i++)
 781              {
 782                  *(Packet + (i / 4)) <<= 2;
 783                  *(Packet + (i / 4)) |= ((CtrCmd & ((u8)1 << (i - 24))) ? 2 : 1);
 784              }
 785              for (i = 32; i < 48; i++)
 786              {
 787                  *(Packet + (i / 4)) <<= 2;
 788                  *(Packet + (i / 4)) |= ((CRCTemp & ((u16)1 << (i - 32))) ? 2 : 1);
 789              }
 790              ClearWDT();
 791          }*/
 792          
 793          void TX_DataLoad_HighSpeed(u32 IDCache, Wireless_Body CtrCmd, u8 *Packet)
 794          {
 795   1          xdata u8 i;
 796   1          xdata u16 CRCTemp = 0;
 797   1      
 798   1          CRCTemp = (IDCache & 0xffff) + (((IDCache >> 16) & 0xff) + ((u16)CtrCmd.Fno_Type.byte << 8));
 799   1        for(i=0;i<4;i++)
 800   1          CRCTemp+=CtrCmd.Data[i].ui;
 801   1      
 802   1          for (i = 0; i < 24; i++)
 803   1          {
 804   2              *(Packet + (i / 4)) <<= 2;
 805   2              *(Packet + (i / 4)) |= ((IDCache & ((u32)1 << i)) ? 2 : 1);
 806   2          }
 807   1          for (i = 24; i < 32; i++)
 808   1          {
 809   2              *(Packet + (i / 4)) <<= 2;
 810   2              *(Packet + (i / 4)) |= ((CtrCmd.Fno_Type.byte & ((u8)1 << (i - 24))) ? 2 : 1);
 811   2          }
 812   1        ClearWDT();
 813   1          for (i = 32; i < 48; i++)
 814   1          {
 815   2              *(Packet + (i / 4)) <<= 2;
 816   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[0].ui & ((u16)1 << (i - 32))) ? 2 : 1);
 817   2          }
 818   1          for (i = 48; i < 64; i++)
 819   1          {
 820   2              *(Packet + (i / 4)) <<= 2;
 821   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[1].ui & ((u16)1 << (i - 48))) ? 2 : 1);
 822   2          }
 823   1        ClearWDT();
 824   1          for (i = 64; i < 80; i++)
 825   1          {
 826   2              *(Packet + (i / 4)) <<= 2;
 827   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[2].ui & ((u16)1 << (i - 64))) ? 2 : 1);
 828   2          }
 829   1          for (i = 80; i < 96; i++)
 830   1          {
 831   2              *(Packet + (i / 4)) <<= 2;
 832   2              *(Packet + (i / 4)) |= ((CtrCmd.Data[3].ui & ((u16)1 << (i - 80))) ? 2 : 1);
 833   2          }
 834   1          ClearWDT();
C51 COMPILER V9.60.0.0   ML7345                                                            03/15/2022 16:01:50 PAGE 15  

 835   1          for (i = 96; i < 112; i++)
 836   1          {
 837   2              *(Packet + (i / 4)) <<= 2;
 838   2              *(Packet + (i / 4)) |= ((CRCTemp & ((u16)1 << (i - 96))) ? 2 : 1);
 839   2          }
 840   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7036    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    133    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
