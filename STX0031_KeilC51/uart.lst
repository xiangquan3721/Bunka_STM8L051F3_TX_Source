C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\STX0031_KeilC51\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\uart.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\user\inc;.\include) DE
                    -BUG OBJECTEXTEND PRINT(.\STX0031_KeilC51\uart.lst) TABS(2) OBJECT(.\STX0031_KeilC51\uart.obj)

line level    source

   1          #include "uart.h"
   2          
   3          #define T1_BRGRL_9600_2X_16000000_1T 0x98
   4          
   5          xdata u8 uart0_rx_len = 0;
   6          xdata u8 uart0_tx_len = 0;
   7          bit rx_done = 0;
   8          
   9          xdata u8 UartStatus = FrameHeadSataus;
  10          xdata u8 UartLen = 0;
  11          xdata u8 UartCount = 0;
  12          xdata u8 UART_DATA_buffer[UartBuff_MaxLength] = {0};
  13          xdata u8 UART_DATA_ID98[41] = {0};
  14          
  15          xdata __Databits_t Databits_t = {0};
  16          xdata __U1Statues U1Statues = {0};
  17          idata u8 ACKBack[3] = {0x02, 0x03, 0x00};
  18          xdata u8 U1AckTimer = 0;
  19          
  20          xdata u8 FLAG_testNo91=0;
  21          xdata u8 FLAG_testBEEP=0;
  22          xdata u8 FLAG_testNo91_step=0;
  23          xdata u8 FLAG_testNo91SendUart=0;
  24          
  25          
  26          /***********************************************************************************
  27          函数名称:   void InitUart0_S1BRG(void)
  28          功能描述:   Uart0初始化
  29               使用S1BRG作为波特率来源
  30          输入参数:   
  31          返回参数:     
  32          *************************************************************************************/
  33          /*
  34          void Init_Uart0_S1BRG(void)
  35          {
  36            //PORT_SetP3QuasiBi(BIT0|BIT1|BIT3|BIT4|BIT5);    // 设置 P30,P31作为准双向口
  37              
  38            UART0_SetMode8bitUARTVar();     // 8位 可变波特率
  39            UART0_EnReception();        // 使能UART1接收数据
  40            
  41            UART0_SetBRGFromS1BRG();      // 设置波特率来源为 S1BRG
  42            UART0_SetS1BRGBaudRateX2();     // 设置2x波特率
  43            UART1_SetS1BRGSelSYSCLK();      // 设置S1BRG时钟输入为Sysclk
  44          
  45              // 设置波特率
  46            UART1_SetS1BRGValue(S1BRG_BRGRL_9600_2X_24000000_1T); 
  47            
  48            UART1_EnS1BRG();          // 开启S1BRG时钟
  49          }
  50          */
  51          /*
  52          void Init_Uart0_T1(void)
  53          {
  54              UART0_SetMode8bitUARTVar();     // 8位 可变波特率
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 2   

  55            UART0_EnReception();        // 使能UART0接收数据
  56            
  57            UART0_SetBRGFromT1();       // 设置波特率来源为 T1
  58            UART0_SetT1BaudRateX2();      // 设置2x波特率
  59          
  60            TM_SetT1Mode_2_8BIT_AUTORELOAD();
  61            TM_SetT1Clock_SYSCLK();
  62            TM_SetT1Gate_Disable(); 
  63          
  64              // 设置波特率
  65            TM_SetT1HighByte(T1_BRGRL_9600_2X_24000000_1T);
  66            TM_SetT1LowByte(T1_BRGRL_9600_2X_24000000_1T);
  67          
  68            TM_EnableT1();
  69          }*/
  70          
  71          
  72          //P119; 波特率baud: TH1 = 256 - (SYSCLK / (baud / ((2^SMOD1 * 2^(SMOD2*2))/32)))
  73          void Init_Uart0_T1_ODD(void)
  74          {
  75   1          UART0_SetMode9bitUARTVar();     // 9位 可变波特率
  76   1        UART0_EnReception();        // 使能UART0接收数据
  77   1         
  78   1        UART0_SetBRGFromT1();       // 设置波特率来源为 T1
  79   1        UART0_SetT1BaudRateX2();      // 设置2x波特率,SMOD1=1,SMOD2=0
  80   1      
  81   1        TM_SetT1Mode_2_8BIT_AUTORELOAD();   // 定时器1工作在8位自动重载定时器/计数模式
  82   1        TM_SetT1Clock_SYSCLK();             // T1X12=1,
  83   1        TM_SetT1Gate_Disable(); 
  84   1      
  85   1          // 设置波特率
  86   1      #if (MCU_SYSCLK == 16000000)
  87   1          TM_SetT1HighByte(T1_BRGRL_9600_2X_16000000_1T);
  88   1        TM_SetT1LowByte(T1_BRGRL_9600_2X_16000000_1T);
  89   1      #endif
  90   1          
  91   1      #if (MCU_SYSCLK == 24000000)
                TM_SetT1HighByte(T1_BRGRL_9600_2X_24000000_1T);
                TM_SetT1LowByte(T1_BRGRL_9600_2X_24000000_1T);
              #endif
  95   1      
  96   1        TM_EnableT1();
  97   1      }
  98          
  99          
 100          
 101          /***********************************************************************************
 102          函数名称:   void INT_UART0(void)
 103          功能描述:UART0 中断服务程序
 104               
 105          输入参数:   
 106          返回参数:     
 107          *************************************************************************************/
 108          void INT_UART0(void) interrupt INT_VECTOR_UART0
 109          {
 110   1          idata u8 dat = 0;
 111   1        _push_(SFRPI);       //保护SFRPI寄存器值
 112   1      
 113   1        SFR_SetPage(0);      /*设置0页寄存器*/  //S0CON仅0页操作
 114   1        if(TI0)         //发送中断内容
 115   1        { 
 116   2           TI0 = 0;    
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 3   

 117   2        }
 118   1        if(RI0)         //接收中断内容
 119   1        {
 120   2          RI0 = 0;        //清除中断标志
 121   2              dat = S0BUF;
 122   2              if(Flag_test_mode == 0) ReceiveFrame(dat);
 123   2              else
 124   2              {
 125   3                  if(dat == '(') SIO_cnt = 0;
 126   3                  SIO_buff[SIO_cnt] = dat;
 127   3                  SIO_cnt = (SIO_cnt + 1) & 0x1F;
 128   3                  if (dat == ')')
 129   3                  {
 130   4                      for (dat = 0; dat < SIO_cnt; dat++)
 131   4                      {
 132   5                          SIO_DATA[dat] = SIO_buff[dat];
 133   5                      }
 134   4                      BIT_SIO = 1; // 标志
 135   4                      //SIO_TOT = 20;
 136   4                  }
 137   3              }
 138   2        }
 139   1        _pop_(SFRPI);      //恢复SFRPI寄存器值
 140   1      }
 141          
 142          /***********************************************************************************
 143          函数名称:void Uart0SendByte(u8 tByte)
 144          功能描述:Uart0发送数据
 145          输入参数:u8 tByte: 待发送的数据
 146          返回参数:     
 147          *************************************************************************************/
 148          void Uart0SendByte(u8 tByte)
 149          {
 150   1        bit bES;
 151   1        bES = ES0;
 152   1        ES0 = 0;
 153   1        S0BUF = tByte;
 154   1          //TB80 = P;   //校验位
 155   1        while(TI0 == 0);
 156   1        TI0 = 0;
 157   1        ES0 = bES;
 158   1      }
 159          
 160          /* 发送数据 */
 161          void Send_Data(u8 *buff,u8 len)
 162          {
 163   1          xdata u8 i = 0;
 164   1          for(i=0; i<len; i++)
 165   1          {
 166   2              Uart0SendByte(buff[i]);
 167   2          }
 168   1      }
 169          
 170          unsigned char asc_hex(unsigned char asc) // HEX
 171          {
 172   1        xdata u8 i;
 173   1        if (asc < 0x3A)
 174   1          i = asc & 0x0F;
 175   1        else
 176   1          i = asc - 0x37;
 177   1        return i;
 178   1      }
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 4   

 179          
 180          unsigned char hex_asc(unsigned char hex)
 181          {
 182   1        xdata u8 i;
 183   1        hex = hex & 0x0F;
 184   1        if (hex < 0x0A)
 185   1          i = hex | 0x30;
 186   1        else
 187   1          i = hex + 0x37;
 188   1        return i;
 189   1      }
 190          
 191          unsigned char asc_hex_2(unsigned char asc1, unsigned char asc0)
 192          {
 193   1        unsigned char i;
 194   1        i = (asc_hex(asc1) << 4) + (asc_hex(asc0) & 0x0F);
 195   1        return i;
 196   1      }
 197          
 198          
 199          void ReceiveFrame(u8 Cache)
 200          {
 201   1        switch (UartStatus)
 202   1        {
 203   2        case FrameHeadSataus:
 204   2        {
 205   3          UART_DATA_buffer[0] = UART_DATA_buffer[1];
 206   3          UART_DATA_buffer[1] = UART_DATA_buffer[2];
 207   3          UART_DATA_buffer[2] = Cache;
 208   3          if ((UART_DATA_buffer[0] == FrameHead) &&
 209   3            (UART_DATA_buffer[2] == FrameSingnalID))
 210   3          {
 211   4            U1Statues = ReceivingStatues;
 212   4            UartStatus++;
 213   4            UartLen = UART_DATA_buffer[1];
 214   4                  if(UartLen >= UartBuff_MaxLength)    UartStatus = FrameHeadSataus;  //overflow
 215   4          }
 216   3        }
 217   2        break;
 218   2        case DataStatus:
 219   2        {
 220   3          UART_DATA_buffer[UartCount + 3] = Cache;
 221   3          UartCount++;
 222   3          if (UartCount >= (UartLen - 3))
 223   3            UartStatus++;
 224   3        }
 225   2        break;
 226   2        default:
 227   2          UartStatus = 0;
 228   2          U1Statues = IdelStatues;
 229   2          break;
 230   2        }
 231   1        if (UartStatus == FrameEndStatus) //接收完一帧处理数
 232   1        {
 233   2          //add Opration function
 234   2          OprationFrame();
 235   2          UartStatus = 0;
 236   2          UartCount = 0;
 237   2          //        Receiver_LED_OUT_INV = !Receiver_LED_OUT_INV;
 238   2          if((Databits_t.No.ID_No == 147)||(Databits_t.No.ID_No == 152)) U1Statues = IdelStatues;
 239   2          else
 240   2          { 
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 5   

 241   3            U1Statues = ReceiveDoneStatues;
 242   3              U1AckTimer = U1AckDelayTime;
 243   3          }
 244   2        }
 245   1      }
 246          
 247          void OprationFrame(void)
 248          {
 249   1        idata u8 i = 0;;
 250   1        for (i = 0; i < 4; i++)
 251   1          Databits_t.Data[i] = UART_DATA_buffer[3 + i];
 252   1        if (Databits_t.No.ID_No == 146)  //0x92
 253   1        {
 254   2            FLAG_APP_TX_fromUART=1;
 255   2          if(TIMER1s);
 256   2          else Uart_Struct_DATA_Packet_Contro.Fno_Type.UN.fno=0;
 257   2          //for(i=0;i<3;i++)Uart_Struct_DATA_Packet_Contro.data[i/2].uc[i%2]=Databits_t.Data[i+1];
 258   2          //for(i=3;i<8;i++)Uart_Struct_DATA_Packet_Contro.data[i/2].uc[i%2]=0x00;
 259   2      
 260   2          for(i=0;i<2;i++)Uart_Struct_DATA_Packet_Contro.Data[i/2].uc[i%2] = Databits_t.Data[i+1];
 261   2          if((Databits_t.No.Statues==3)||(Databits_t.No.Statues==4))  Flag_shutter_stopping=1;
 262   2          else Flag_shutter_stopping=0;
 263   2          ACKBack[2] = 0;
 264   2          switch (Databits_t.No.Mode)
 265   2          {
 266   3          case 3:
 267   3          case 4:
 268   3          case 5:
 269   3          case 6:
 270   3          case 7:
 271   3          case 8:
 272   3            break;
 273   3          default:
 274   3            ACKBack[2] = 1;
 275   3            return;
 276   3            break;
 277   3          }
 278   2          switch (Databits_t.No.Statues)
 279   2          {
 280   3          case 1:
 281   3          case 2:
 282   3          case 3:
 283   3          case 4:
 284   3          case 5:
 285   3          case 6:
 286   3            break;
 287   3          default:
 288   3            ACKBack[2] = 1;
 289   3            return;
 290   3            break;
 291   3          }
 292   2          switch (Databits_t.No.Abnormal)
 293   2          {
 294   3          case 0x00:
 295   3          case 0x04:
 296   3          case 0x06:
 297   3          case 0x45:
 298   3          case 0x46:
 299   3          case 0x47:
 300   3          case 0x48:
 301   3          case 0x49:
 302   3          case 0x4A:
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 6   

 303   3          case 0x4B:
 304   3          case 0x4C:
 305   3          case 0x4D:
 306   3            break;
 307   3          default:
 308   3            ACKBack[2] = 1;
 309   3            return;
 310   3            break;
 311   3          }
 312   2        }
 313   1        else if (Databits_t.No.ID_No == 152)  //0x98
 314   1        {
 315   2            Flag_ERROR_Read_once_again=0;
 316   2          TIME_ERROR_Read_once_again=0;
 317   2          for (i = 0; i < 41; i++)UART_DATA_ID98[i]=UART_DATA_buffer[i];
 318   2          FLAG_APP_TX_fromUART_err_read=1;
 319   2          Time_error_read_timeout=(UART_DATA_ID98[1]+1)*7;
 320   2          ERROR_Read_sendTX_count=0;
 321   2          ERROR_Read_sendTX_packet=0;
 322   2          Time_error_read_gap=38;
 323   2        }
 324   1        else if (Databits_t.No91.ID_test_No91or93 == 145)  //0x91
 325   1        {
 326   2            if((ID_DATA_PCS==0)&&(ID_SCX1801_DATA==0))
 327   2              {
 328   3            ACKBack[2] = 0;
 329   3            FLAG_testNo91=1;
 330   3              if(FLAG_testNo91_step<3)
 331   3                   FLAG_testNo91_step++;
 332   3            FLAG_testNo91SendUart=0;
 333   3            TIME_TestNo91=1000;
 334   3              }
 335   2          else
 336   2            {
 337   3            ACKBack[2] = 1;
 338   3            FLAG_testNo91=2;
 339   3            TIME_TestNo91=1000;
 340   3            FLAG_testBEEP=1;
 341   3            }
 342   2        }
 343   1        else if (Databits_t.No91.ID_test_No91or93 == 147)  //0x93
 344   1        {
 345   2          switch (Databits_t.No91.SWorOUT)
 346   2          {
 347   3          case 0x01:
 348   3            DATA_Packet_Control=0x08;
 349   3            TIMER1s = 1000;
 350   3            break;
 351   3          case 0x02:
 352   3            DATA_Packet_Control=0x04;
 353   3            TIMER1s = 1000;
 354   3            break;
 355   3          case 0x04:
 356   3            DATA_Packet_Control=0x02;
 357   3            TIMER1s = 1000;
 358   3            break;
 359   3          case 0xFA:
 360   3            FLAG_testBEEP=1;
 361   3            break;
 362   3          case 0xFB:
 363   3            FLAG_testBEEP=2;
 364   3            break;
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 7   

 365   3          case 0xFC:
 366   3            FLAG_testBEEP=3;
 367   3            break;
 368   3          default:
 369   3            break;
 370   3          }
 371   2      
 372   2        }
 373   1        else
 374   1        {
 375   2          ACKBack[2] = 1;
 376   2          return;
 377   2        }
 378   1      }
 379          
 380          
 381          void TranmissionACK(void)
 382          {
 383   1          if ((U1Statues == ReceiveDoneStatues) && (U1AckTimer == 0))
 384   1          {
 385   2              U1Statues = ACKingStatues;
 386   2              Send_Data(ACKBack, 3);
 387   2              U1Statues = IdelStatues;
 388   2          }
 389   1      
 390   1        if((Flag_ERROR_Read_once_again==1)&&(TIME_ERROR_Read_once_again==0))
 391   1        {
 392   2          Send_Data(Send_err_com, 7);
 393   2          Flag_ERROR_Read_once_again=0;
 394   2          TIME_ERROR_Read_once_again=0;
 395   2        }
 396   1      }
 397          
 398          xdata u32 PROFILE_CH_FREQ_32bit_200002EC_uart = 0;
 399          void PC_PRG(void) // 串口命令
 400          {
 401   1        xdata u8 send_dat[10] = {0};
 402   1          xdata u8 send_ok[4] = {'(','O','K',')'};
 403   1          xdata uni_rom_id UART_ID_data;
 404   1          xdata u8 re_byte = 0;
 405   1      
 406   1          if (BIT_SIO)
 407   1        {
 408   2          BIT_SIO = 0;
 409   2          //SIO_TOT = 20;
 410   2              if(SIO_DATA[1] == 'T' && SIO_DATA[2] == 'E' && SIO_DATA[3] == 'S' && SIO_DATA[4] == 'T' && SIO_DAT
             -A[5]==')')
 411   2              {
 412   3                  Flag_test_pc = 1;
 413   3                  Flag_test_rssi = 0;
 414   3                  Flag_test_fm = 0;
 415   3                  Receiver_LED_OUT = 0;
 416   3                  Receiver_LED_TX = 0;
 417   3                  Receiver_LED_RX = 0;
 418   3                  Receiver_OUT_STOP = 0;
 419   3                  Receiver_OUT_CLOSE = 0;
 420   3                  Receiver_OUT_OPEN = 0;
 421   3                  X_COUNT = 0;
 422   3                  X_ERR = 0;
 423   3                  X_ERR_CNT = 0;
 424   3                  ML7345_SetAndGet_State(Force_TRX_OFF);
 425   3                  Send_Data(send_ok,4);
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 8   

 426   3              }
 427   2              if(Flag_test_pc == 1)
 428   2              {
 429   3                  switch(SIO_DATA[1])
 430   3                  {
 431   4                      case 'S':
 432   4                          if(SIO_DATA[2] == ')')
 433   4                          {
 434   5                              if(Flag_test_rssi == 1) Receiver_LED_RX = 0;
 435   5                              Flag_test_rssi = 0;
 436   5                              Flag_test_fm = 0;
 437   5                              CG2214M6_USE_T;
 438   5                              ML7345_SetAndGet_State(Force_TRX_OFF);
 439   5                              ML7345_Frequency_Set(Fre_429_175,1);
 440   5                              Tx_Data_Test(0);    //发载波
 441   5                              Send_Data(send_ok,4);
 442   5                          }
 443   4                          break;
 444   4                      case 'E':
 445   4                          if(SIO_DATA[2]=='N' && SIO_DATA[3]=='D' && SIO_DATA[4]==')')
 446   4                          {
 447   5                              Flag_test_pc = 0;
 448   5                              Flag_test_rssi = 0;
 449   5                              Flag_test_fm = 0;
 450   5                              Receiver_LED_OUT = 0;
 451   5                              Receiver_LED_TX = 0;
 452   5                              Receiver_LED_RX = 0;
 453   5                              Receiver_OUT_STOP = 0;
 454   5                              Receiver_OUT_CLOSE = 0;
 455   5                              Receiver_OUT_OPEN = 0;
 456   5                              X_COUNT = 0;
 457   5                              X_ERR = 0;
 458   5                              X_ERR_CNT = 0;
 459   5                              ML7345_SetAndGet_State(Force_TRX_OFF);
 460   5                              Send_Data(send_ok,4);
 461   5                          }
 462   4                          else if(SIO_DATA[2]=='H' && SIO_DATA[3]==')')
 463   4                          {
 464   5                              ID_DATA_PCS = 0;
 465   5                              ALL_ID_EEPROM_Erase();
 466   5                              ID_SCX1801_DATA = 0;
 467   5                              ID_SCX1801_EEPROM_write(0x00);
 468   5                              Send_Data(send_ok,4);
 469   5                          }
 470   4                          break;
 471   4                      case 'F':
 472   4                          if(SIO_DATA[2]=='M' && SIO_DATA[3]==')')  //载波+调制
 473   4                          {
 474   5                              if(Flag_test_rssi == 1) Receiver_LED_RX = 0;
 475   5                              Flag_test_rssi = 0;
 476   5                              Flag_test_fm = 1;
 477   5                              CG2214M6_USE_T;
 478   5                              ML7345_SetAndGet_State(Force_TRX_OFF);
 479   5                              ML7345_Frequency_Set(Fre_429_175,1);
 480   5                              Tx_Data_Test(1);
 481   5                              Send_Data(send_ok,4);
 482   5                          }
 483   4                          else if(SIO_DATA[2]=='C' && SIO_DATA[3]=='?' && SIO_DATA[4]==')')
 484   4                          {
 485   5                              send_dat[0] = '(';
 486   5                              send_dat[1] = 'F';
 487   5                              send_dat[2] = 'C';
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 9   

 488   5                              send_dat[3] = hex_asc(rf_offset / 16);
 489   5                              send_dat[4] = hex_asc(rf_offset % 16);
 490   5                              send_dat[5] = ')';
 491   5                              Send_Data(send_dat,6);
 492   5                          }
 493   4                          else if (SIO_DATA[2]=='C' && SIO_DATA[5]==')' && Flag_test_fm == 1)
 494   4                          {
 495   5                              Flag_test_rssi = 0;
 496   5                              re_byte = asc_hex_2(SIO_buff[3],SIO_buff[4]);
 497   5                              ML7345_SetAndGet_State(Force_TRX_OFF);
 498   5                              CG2214M6_USE_T;
 499   5                              if(re_byte <= 10) //frequency +
 500   5                              {
 501   6                                  rf_offset = re_byte;
 502   6                                  IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rf_offset,&rf_offset,1);
 503   6                                  PROFILE_CH_FREQ_32bit_200002EC_uart = 429175000 + 150 * re_byte;
 504   6                                  ML7345_Frequency_Calcul(PROFILE_CH_FREQ_32bit_200002EC_uart,Fre_429_175);
 505   6                                  ML7345_Frequency_Set(Fre_429_175,1);
 506   6                                  PROFILE_CH_FREQ_32bit_200002EC_uart = 426750000 + 150 * re_byte;
 507   6                                  ML7345_Frequency_Calcul(PROFILE_CH_FREQ_32bit_200002EC_uart,Fre_426_750);
 508   6                                  Send_Data(send_ok,4);
 509   6                              }
 510   5                              else if(10 < re_byte && re_byte <= 20) //frequency -
 511   5                              {
 512   6                                  rf_offset = re_byte;
 513   6                                  IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rf_offset,&rf_offset,1);
 514   6                                  re_byte = re_byte - 10;
 515   6                                  PROFILE_CH_FREQ_32bit_200002EC_uart = 429175000 - 150 * re_byte;
 516   6                                  ML7345_Frequency_Calcul(PROFILE_CH_FREQ_32bit_200002EC_uart,Fre_429_175);
 517   6                                  ML7345_Frequency_Set(Fre_429_175,1);
 518   6                                  PROFILE_CH_FREQ_32bit_200002EC_uart = 426750000 - 150 * re_byte;
 519   6                                  ML7345_Frequency_Calcul(PROFILE_CH_FREQ_32bit_200002EC_uart,Fre_426_750);
 520   6                                  Send_Data(send_ok,4);
 521   6                              }
 522   5                              Tx_Data_Test(1);
 523   5                          }
 524   4                          break;
 525   4      
 526   4                      case 'R':
 527   4                          if(SIO_DATA[2]=='S' && SIO_DATA[3]=='S' && SIO_DATA[4]=='I' && SIO_DATA[5]==')' && Fla
             -g_test_rssi==1)
 528   4                          {
 529   5                              send_dat[0] = '(';
 530   5                              send_dat[1] = 'R';
 531   5                              send_dat[2] = 'S';
 532   5                              send_dat[3] = 'S';
 533   5                              send_dat[4] = 'I';
 534   5                              send_dat[5] = hex_asc((X_ERR_CNT & 0xff) / 16);
 535   5                              send_dat[6] = hex_asc((X_ERR_CNT & 0xff)% 16);
 536   5                              send_dat[7] = ')';
 537   5                              Send_Data(send_dat,8);
 538   5                          }
 539   4                          else if(SIO_DATA[2]=='S' && SIO_DATA[3]==')')
 540   4                          {
 541   5                              Receiver_LED_RX = 0;
 542   5                              Flag_test_fm = 0;
 543   5                              X_COUNT = 0;
 544   5                              X_ERR = 0;
 545   5                              X_ERR_CNT = 0;
 546   5                              CG2214M6_USE_R;
 547   5                              ML7345_SetAndGet_State(Force_TRX_OFF);
 548   5                              PROFILE_CH_FREQ_32bit_200002EC = 426750000;
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 10  

 549   5                              ML7345_Frequency_Set(Fre_426_750,1);
 550   5                              ML7345_MeasurBER_Init();
 551   5                              ML7345_SetAndGet_State(RX_ON);
 552   5                              Flag_test_rssi = 1;
 553   5                              Send_Data(send_ok,4);
 554   5                          }
 555   4                          else if(SIO_DATA[2]=='N' && SIO_DATA[3]==')')
 556   4                          {
 557   5                              if(ID_SCX1801_DATA != 0) re_byte = ID_DATA_PCS + 1;
 558   5                              else re_byte = ID_DATA_PCS;
 559   5                              send_dat[0] = '(';
 560   5                              send_dat[1] = 'R';
 561   5                              send_dat[2] = 'N';
 562   5                              send_dat[3] = hex_asc((re_byte & 0xff) / 16);
 563   5                              send_dat[4] = hex_asc((re_byte & 0xff) % 16);
 564   5                              send_dat[5] = ')';
 565   5                              re_byte = 0;
 566   5                              Send_Data(send_dat,6);
 567   5                          }
 568   4                          else if(SIO_DATA[2]=='G' && SIO_DATA[5]==')')
 569   4                          {
 570   5                              if(SIO_DATA[3]=='0' && SIO_DATA[4]=='0')
 571   5                              {
 572   6                                  UART_ID_data.IDB[0] = 0;
 573   6                                  UART_ID_data.IDB[1] = IAP_ReadByteByMOVC(addr_eeprom_sys + 0x3FB);
 574   6                                  UART_ID_data.IDB[2] = IAP_ReadByteByMOVC(addr_eeprom_sys + 0x3FC);
 575   6                                  UART_ID_data.IDB[3] = IAP_ReadByteByMOVC(addr_eeprom_sys + 0x3FD);
 576   6                                  if ((UART_ID_data.IDC == 0) || (UART_ID_data.IDC == 0xFFFFFF))  ID_SCX1801_DAT
             -A=0;
 577   6                                  else ID_SCX1801_DATA = UART_ID_data.IDC;
 578   6                                  send_dat[0] = '(';
 579   6                                  send_dat[1] = 'R';
 580   6                                  send_dat[2] = 'G';
 581   6                                  send_dat[3] = hex_asc(UART_ID_data.IDB[1] / 16);
 582   6                                  send_dat[4] = hex_asc(UART_ID_data.IDB[1] % 16);
 583   6                                  send_dat[5] = hex_asc(UART_ID_data.IDB[2] / 16);
 584   6                                  send_dat[6] = hex_asc(UART_ID_data.IDB[2] % 16);
 585   6                                  send_dat[7] = hex_asc(UART_ID_data.IDB[3] / 16);
 586   6                                  send_dat[8] = hex_asc(UART_ID_data.IDB[3] % 16);
 587   6                                  send_dat[9] = ')';
 588   6                                  Send_Data(send_dat,10);
 589   6                              }
 590   5                          }
 591   4                          break;
 592   4                      case 'K':
 593   4                          if(SIO_DATA[2]=='Y' && SIO_DATA[3]==')')
 594   4                          {
 595   5                              send_dat[0] = '(';
 596   5                              send_dat[1] = 'K';
 597   5                              send_dat[2] = 'Y';
 598   5                              send_dat[7] = 0;
 599   5                              send_dat[7] = send_dat[7] | Receiver_Login;
 600   5                              send_dat[3] = hex_asc((send_dat[7] & 0xff) / 16);
 601   5                              send_dat[4] = hex_asc((send_dat[7] & 0xff) % 16);
 602   5                              send_dat[5] = ')';
 603   5                              Send_Data(send_dat,6);
 604   5                          }
 605   4                          break;
 606   4                      case 'P':
 607   4                          if(SIO_DATA[2]=='H' && SIO_DATA[5]==')')
 608   4                          {
 609   5                              if(SIO_DATA[3]=='2' && SIO_DATA[4]=='5')         {Receiver_LED_OUT = 1;  Send_Data
C51 COMPILER V9.60.0.0   UART                                                              03/15/2022 16:13:27 PAGE 11  

             -(send_ok,4);}
 610   5                              else if(SIO_DATA[3]=='2' && SIO_DATA[4]=='7')    {Receiver_LED_TX = 1;   Send_Data
             -(send_ok,4);}
 611   5                              else if(SIO_DATA[3]=='3' && SIO_DATA[4]=='5')    {Receiver_LED_RX = 1;   Send_Data
             -(send_ok,4);}
 612   5                              else if(SIO_DATA[3]=='1' && SIO_DATA[4]=='1')    {Receiver_OUT_STOP = 1; Send_Data
             -(send_ok,4);}
 613   5                              else if(SIO_DATA[3]=='1' && SIO_DATA[4]=='0')    {Receiver_OUT_CLOSE = 1;Send_Data
             -(send_ok,4);}
 614   5                              else if(SIO_DATA[3]=='1' && SIO_DATA[4]=='2')    {Receiver_OUT_OPEN = 1; Send_Data
             -(send_ok,4);}
 615   5                          }
 616   4                          else if(SIO_DATA[2]=='L' && SIO_DATA[5]==')')
 617   4                          {
 618   5                              if(SIO_DATA[3]=='2' && SIO_DATA[4]=='5')         {Receiver_LED_OUT = 0;  Send_Data
             -(send_ok,4);}
 619   5                              else if(SIO_DATA[3]=='2' && SIO_DATA[4]=='7')    {Receiver_LED_TX = 0;   Send_Data
             -(send_ok,4);}
 620   5                              else if(SIO_DATA[3]=='3' && SIO_DATA[4]=='5')    {Receiver_LED_RX = 0;   Send_Data
             -(send_ok,4);}
 621   5                              else if(SIO_DATA[3]=='1' && SIO_DATA[4]=='1')    {Receiver_OUT_STOP = 0; Send_Data
             -(send_ok,4);}
 622   5                              else if(SIO_DATA[3]=='1' && SIO_DATA[4]=='0')    {Receiver_OUT_CLOSE = 0;Send_Data
             -(send_ok,4);}
 623   5                              else if(SIO_DATA[3]=='1' && SIO_DATA[4]=='2')    {Receiver_OUT_OPEN = 0; Send_Data
             -(send_ok,4);}
 624   5                          }
 625   4                          break;
 626   4                      case 'W':
 627   4                          if(SIO_DATA[2]=='G' && SIO_DATA[9]==')')
 628   4                          {
 629   5                              UART_ID_data.IDB[0]=0;
 630   5                              UART_ID_data.IDB[1] = asc_hex_2(SIO_buff[3],SIO_buff[4]);
 631   5                              UART_ID_data.IDB[2] = asc_hex_2(SIO_buff[5],SIO_buff[6]);
 632   5                              UART_ID_data.IDB[3] = asc_hex_2(SIO_buff[7],SIO_buff[8]);
 633   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+0x3FB,&UART_ID_data.IDB[1],3);
 634   5                              
 635   5                              ID_SCX1801_DATA = UART_ID_data.IDC;
 636   5                              Send_Data(send_ok,4);
 637   5                          }
 638   4                          break;
 639   4                      default:
 640   4                          break;
 641   4                  }
 642   3              }
 643   2          }
 644   1          if(Flag_test_rssi == 1) Uart_RF_Ber_Test();
 645   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4503    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =    123    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =      5    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
